<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sources - Disaster Clippy Admin</title>
    <link rel="icon" type="image/png" href="/static/paperclip.png">
    <link rel="stylesheet" href="/admin/static/{{ admin_css }}">
    <link rel="stylesheet" href="/admin/static/source-card.css">
    <style>
        /* Page-specific styles */
        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            border-bottom: 1px solid #0f3460;
            padding-bottom: 0.5rem;
        }
        .tab {
            padding: 0.5rem 1rem;
            background: transparent;
            border: none;
            color: #888;
            cursor: pointer;
            border-radius: 4px 4px 0 0;
            font-size: 0.9rem;
        }
        .tab:hover { color: #4ecca3; }
        .tab.active { background: #0f3460; color: #e94560; }
        .sub-nav {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        .sub-nav a {
            color: #4ecca3;
            text-decoration: none;
            padding: 0.5rem 1rem;
            border: 1px solid #0f3460;
            border-radius: 4px;
            font-size: 0.85rem;
        }
        .sub-nav a:hover { background: #0f3460; }
        .sub-nav a.active { background: #0f3460; color: #e94560; }
        /* Source grid uses class from source-card.css */
        .source-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1rem;
        }
        .placeholder {
            text-align: center;
            padding: 3rem;
            color: #666;
            font-style: italic;
        }
        .loading { text-align: center; padding: 2rem; color: #888; }

        /* Sync mode modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        .modal-overlay.show { display: flex; }
        .modal-content {
            background: #1a1a2e;
            border: 1px solid #4ecca3;
            border-radius: 8px;
            padding: 1.5rem;
            max-width: 500px;
            width: 90%;
        }
        .modal-title {
            color: #f9a825;
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }
        .modal-body { color: #ccc; font-size: 0.9rem; margin-bottom: 1.5rem; }
        .modal-body strong { color: #4ecca3; }
        .modal-body .count { color: #e94560; font-weight: 600; }
        .modal-actions { display: flex; gap: 0.75rem; justify-content: flex-end; }
        .btn-update { background: #0f3460; border: 1px solid #4ecca3; }
        .btn-update:hover { background: #1a4a7a; }
        .btn-replace { background: #5c2030; border: 1px solid #e94560; }
        .btn-replace:hover { background: #7a2a40; }

        /* Model cards styles */
        .model-card {
            background: #1a1a2e;
            border: 1px solid #0f3460;
            border-radius: 8px;
            padding: 1rem;
        }
        .model-card.installed { border-color: #4ecca3; }
        .model-card.active { border-color: #e94560; box-shadow: 0 0 10px rgba(233, 69, 96, 0.2); }
        .model-card h3 { color: #4ecca3; font-size: 1rem; font-weight: 600; margin: 0 0 0.5rem 0; }
        .model-card .model-meta { font-size: 0.8rem; color: #888; margin-bottom: 0.5rem; }
        .model-card .model-meta span { display: inline-block; margin-right: 1rem; }
        .model-card .model-desc { font-size: 0.85rem; color: #aaa; margin-bottom: 0.75rem; }
        .model-card .actions { display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center; margin-top: 0.75rem; }
        .model-card .model-badges {
            display: flex;
            gap: 0.25rem;
            margin-bottom: 0.75rem;
            flex-wrap: wrap;
        }
        .model-badge {
            font-size: 0.65rem;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            text-transform: uppercase;
            font-weight: 500;
        }
        .model-badge.installed { background: #4ecca320; color: #4ecca3; }
        .model-badge.active { background: #e9456020; color: #e94560; }
        .model-badge.recommended { background: #f9a82520; color: #f9a825; }
        .model-section-title {
            color: #4ecca3;
            margin: 1.5rem 0 0.75rem 0;
            font-size: 1rem;
            border-bottom: 1px solid #0f3460;
            padding-bottom: 0.5rem;
        }
        .system-info-box {
            background: #0f3460;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
            font-size: 0.85rem;
        }
        .system-info-box .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }
        .system-info-box .info-label { color: #888; }
        .system-info-box .info-value { color: #4ecca3; }
        .progress-bar {
            height: 4px;
            background: #0f3460;
            border-radius: 2px;
            margin-top: 0.5rem;
            overflow: hidden;
        }
        .progress-bar .progress-fill {
            height: 100%;
            background: #4ecca3;
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        /* Unified button styles for Models and Languages tabs */
        .btn-small {
            padding: 0.4rem 0.8rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: background 0.2s, opacity 0.2s;
        }
        .btn-small:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-edit {
            background: #0f3460;
            color: #4ecca3;
            border: 1px solid #0f3460;
        }
        .btn-edit:hover:not(:disabled) {
            background: #1a4a7a;
        }
        .btn-install {
            background: #0f3460;
            color: #4ecca3;
            border: 1px solid #0f3460;
        }
        .btn-install:hover:not(:disabled) {
            background: #1a4a7a;
        }
        .btn-danger {
            background: #5c2030;
            color: #e94560;
            border: 1px solid #5c2030;
        }
        .btn-danger:hover:not(:disabled) {
            background: #7a2a40;
        }
    </style>
</head>
<body>
    <header>
        <div>
            <h1>Sources</h1>
            <p>Manage your content sources and packs</p>
        </div>
        {% with active_page='sources' %}{% include '_nav.html' %}{% endwith %}
    </header>

    <div class="container">
        <!-- Sub-navigation -->
        <div class="sub-nav">
            <a href="/useradmin/sources" class="active">All Sources</a>
            <a href="/useradmin/sources/tools">Source Tools</a>
            <a href="/useradmin/job-builder">Job Builder</a>
        </div>

        <!-- Tabs for filtering -->
        <div class="section">
            <div class="tabs">
                <button class="tab active" data-filter="all">All</button>
                <button class="tab" data-filter="installed">Installed</button>
                <button class="tab" data-filter="available">Available</button>
                <button class="tab" data-filter="local">Local Only</button>
                <button class="tab" data-filter="languages">Languages</button>
                <button class="tab" data-filter="models">LLM Models</button>
            </div>

            <!-- All tab content - shows 4 sections -->
            <div id="allTabContent">
                <h3 style="color: #4ecca3; margin: 1rem 0 0.5rem 0; font-size: 0.95rem;">Local Sources</h3>
                <div id="localSection" class="source-grid">
                    <div class="loading">Loading...</div>
                </div>

                <h3 style="color: #4ecca3; margin: 1.5rem 0 0.5rem 0; font-size: 0.95rem;">Installed Sources</h3>
                <div id="installedSection" class="source-grid">
                    <div class="loading">Loading...</div>
                </div>

                <h3 style="color: #4ecca3; margin: 1.5rem 0 0.5rem 0; font-size: 0.95rem;">Languages</h3>
                <div id="languagesSection" class="source-grid">
                    <div class="loading">Loading languages...</div>
                </div>

                <h3 style="color: #4ecca3; margin: 1.5rem 0 0.5rem 0; font-size: 0.95rem;">LLM Models</h3>
                <div id="modelsSection" class="source-grid">
                    <div class="loading">Loading models...</div>
                </div>
            </div>

            <!-- Single filter tab content -->
            <div id="filterTabContent" style="display: none;">
                <div id="sourcesList" class="source-grid">
                    <div class="loading">Loading sources...</div>
                </div>
            </div>

            <!-- Languages tab content -->
            <div id="languagesTabContent" style="display: none;">
                <div id="languageSystemInfo" class="system-info-box">
                    <div class="info-row">
                        <span class="info-label">Active Language:</span>
                        <span class="info-value" id="activeLanguage">English (default)</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Translation Enabled:</span>
                        <span class="info-value" id="translationEnabled">No</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Cache Size:</span>
                        <span class="info-value" id="cacheSize">0 MB</span>
                    </div>
                </div>

                <h3 class="model-section-title">Available Language Packs</h3>
                <p style="color: #888; font-size: 0.85rem; margin-bottom: 1rem;">
                    Download language packs to translate article content offline. Chat remains in English (Phase 1).
                </p>
                <div id="languagePacksList" class="source-grid">
                    <div class="loading">Loading language packs...</div>
                </div>

                <h3 class="model-section-title" style="margin-top: 2rem;">Translation Cache</h3>
                <div id="cacheStatsBox" class="system-info-box">
                    <div class="info-row">
                        <span class="info-label">Cached Articles:</span>
                        <span class="info-value" id="cachedArticleCount">0</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Cache Languages:</span>
                        <span class="info-value" id="cachedLanguages">None</span>
                    </div>
                    <div style="margin-top: 0.75rem;">
                        <button class="btn-small btn-edit" onclick="clearTranslationCache()">Clear Cache</button>
                    </div>
                </div>
            </div>

            <!-- Models tab content -->
            <div id="modelsTabContent" style="display: none;">
                <div id="modelsSystemInfo" class="system-info-box">
                    <div class="info-row">
                        <span class="info-label">System RAM:</span>
                        <span class="info-value" id="systemRam">--</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Available Storage:</span>
                        <span class="info-value" id="systemStorage">--</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Recommended Tier:</span>
                        <span class="info-value" id="systemTier">--</span>
                    </div>
                </div>

                <h3 class="model-section-title">Embedding Models (for Semantic Search)</h3>
                <div id="embeddingModels" class="source-grid">
                    <div class="loading">Loading models...</div>
                </div>

                <h3 class="model-section-title">LLM Models (for AI Conversation)</h3>
                <div id="llmModels" class="source-grid">
                    <div class="loading">Loading models...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let allSources = [];
        let currentFilter = 'all';

        // Pending install state for sync mode modal
        let pendingInstallSourceId = null;
        let pendingInstallIncludeBackup = false;
        let pendingInstallButton = null;
        let pendingInstallOriginalText = '';

        async function loadSources() {
            const container = document.getElementById('sourcesList');
            container.innerHTML = '<div class="loading">Loading sources...</div>';

            try {
                // Fetch local sources
                const localResp = await fetch('/useradmin/api/local-sources');
                const localData = await localResp.json();
                const localSources = localData.sources || [];

                // Fetch cloud/global sources
                let cloudSources = [];
                try {
                    const cloudResp = await fetch('/useradmin/api/cloud-sources');
                    const cloudData = await cloudResp.json();
                    cloudSources = cloudData.sources || [];
                } catch (e) {
                    console.log('Cloud sources not available:', e);
                }

                // Build combined list with status
                const localIds = new Set(localSources.map(s => s.source_id));
                const cloudIds = new Set(cloudSources.map(s => s.source_id));

                allSources = [];

                // Add local sources with status
                for (const source of localSources) {
                    const isInCloud = cloudIds.has(source.source_id);
                    allSources.push({
                        ...source,
                        status: isInCloud ? 'installed' : 'local_only',
                        is_cloud: isInCloud,
                        is_local: true
                    });
                }

                // Add cloud sources (mark if installed locally)
                for (const source of cloudSources) {
                    const isLocal = localIds.has(source.source_id);
                    if (!isLocal) {
                        // Not installed locally - add as available
                        allSources.push({
                            ...source,
                            status: 'available',
                            is_cloud: true,
                            is_local: false
                        });
                    }
                    // Note: installed cloud sources are already added above from localSources
                }

                renderSources();
            } catch (e) {
                container.innerHTML = '<div class="placeholder">Error loading sources: ' + e.message + '</div>';
            }
        }

        function renderSources() {
            // Handle "All" tab - show sectioned view
            if (currentFilter === 'all') {
                document.getElementById('allTabContent').style.display = 'block';
                document.getElementById('filterTabContent').style.display = 'none';
                document.getElementById('languagesTabContent').style.display = 'none';
                document.getElementById('modelsTabContent').style.display = 'none';

                // Render Local section
                const localSources = allSources.filter(s => s.status === 'local_only');
                const localContainer = document.getElementById('localSection');
                if (localSources.length === 0) {
                    localContainer.innerHTML = '<div class="placeholder">No local-only sources</div>';
                } else {
                    localContainer.innerHTML = localSources.map(s => renderSourceCard(s)).join('');
                }

                // Render Installed section
                const installedSources = allSources.filter(s => s.status === 'installed');
                const installedContainer = document.getElementById('installedSection');
                if (installedSources.length === 0) {
                    installedContainer.innerHTML = '<div class="placeholder">No installed sources</div>';
                } else {
                    installedContainer.innerHTML = installedSources.map(s => renderSourceCard(s)).join('');
                }

                return;
            }

            // Handle Languages tab
            if (currentFilter === 'languages') {
                document.getElementById('allTabContent').style.display = 'none';
                document.getElementById('filterTabContent').style.display = 'none';
                document.getElementById('languagesTabContent').style.display = 'block';
                document.getElementById('modelsTabContent').style.display = 'none';
                return;
            }

            // Handle Models tab
            if (currentFilter === 'models') {
                document.getElementById('allTabContent').style.display = 'none';
                document.getElementById('filterTabContent').style.display = 'none';
                document.getElementById('languagesTabContent').style.display = 'none';
                document.getElementById('modelsTabContent').style.display = 'block';
                return;
            }

            // Handle other filter tabs (Installed, Available, Local Only)
            document.getElementById('allTabContent').style.display = 'none';
            document.getElementById('filterTabContent').style.display = 'block';
            document.getElementById('languagesTabContent').style.display = 'none';
            document.getElementById('modelsTabContent').style.display = 'none';

            const container = document.getElementById('sourcesList');

            // Filter based on current tab
            let filtered = allSources;
            if (currentFilter === 'installed') {
                filtered = allSources.filter(s => s.status === 'installed');
            } else if (currentFilter === 'available') {
                // Show ALL cloud sources (both installed and not)
                // Sort: not-installed first, already-installed last
                filtered = allSources
                    .filter(s => s.is_cloud === true)
                    .sort((a, b) => {
                        // 'available' (not installed) comes before 'installed'
                        if (a.status === 'available' && b.status !== 'available') return -1;
                        if (a.status !== 'available' && b.status === 'available') return 1;
                        // Within same status, sort alphabetically by name
                        return (a.name || a.source_id).localeCompare(b.name || b.source_id);
                    });
            } else if (currentFilter === 'local') {
                filtered = allSources.filter(s => s.status === 'local_only');
            }

            if (filtered.length === 0) {
                let message = 'No sources found.';
                if (currentFilter === 'installed') {
                    message = 'No installed sources. Sources from the global cloud that you have locally appear here.';
                } else if (currentFilter === 'available') {
                    message = 'No sources available from the global cloud. Check your cloud connection.';
                } else if (currentFilter === 'local') {
                    message = 'No local-only sources. Custom sources you create that are not in the global cloud appear here.';
                }
                container.innerHTML = `<div class="placeholder">${message}</div>`;
                return;
            }

            container.innerHTML = filtered.map(source => renderSourceCard(source)).join('');
        }

        function renderSourceCard(source) {
            // Use unified SourceCard renderer
            return SourceCard.render(source, { variant: 'sources' });
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function installSource(sourceId, includeBackup = false, btn = null) {
            // Find the button and disable it
            btn = btn || event.target;
            const originalText = btn.textContent;
            btn.disabled = true;
            btn.textContent = 'Checking...';
            btn.style.opacity = '0.7';

            try {
                // Check if source already exists locally
                const checkResponse = await fetch(`/useradmin/api/local-source-check/${sourceId}`);
                const checkData = await checkResponse.json();

                if (checkData.exists && checkData.vector_count > 0) {
                    // Source exists locally - show modal to choose update or replace
                    pendingInstallSourceId = sourceId;
                    pendingInstallIncludeBackup = includeBackup;
                    pendingInstallButton = btn;
                    pendingInstallOriginalText = originalText;

                    document.getElementById('modalSourceId').textContent = sourceId;
                    document.getElementById('modalVectorCount').textContent = checkData.vector_count.toLocaleString();
                    document.getElementById('syncModeModal').classList.add('show');
                    return;
                }

                // Source doesn't exist locally - proceed with normal install
                await doInstall(sourceId, includeBackup, 'update', btn, originalText);
            } catch (e) {
                alert('Error: ' + e.message);
                btn.textContent = originalText;
                btn.disabled = false;
                btn.style.opacity = '1';
            }
        }

        function closeSyncModal() {
            document.getElementById('syncModeModal').classList.remove('show');
            // Reset button state
            if (pendingInstallButton) {
                pendingInstallButton.textContent = pendingInstallOriginalText;
                pendingInstallButton.disabled = false;
                pendingInstallButton.style.opacity = '1';
            }
            pendingInstallSourceId = null;
            pendingInstallIncludeBackup = false;
            pendingInstallButton = null;
            pendingInstallOriginalText = '';
        }

        async function proceedWithSync(syncMode) {
            console.log('proceedWithSync called with:', syncMode);
            console.log('pendingInstallSourceId:', pendingInstallSourceId);
            console.log('pendingInstallButton:', pendingInstallButton);

            document.getElementById('syncModeModal').classList.remove('show');

            if (!pendingInstallSourceId || !pendingInstallButton) {
                console.error('No pending install - state was cleared');
                alert('Error: Install state was lost. Please try again.');
                return;
            }

            try {
                await doInstall(
                    pendingInstallSourceId,
                    pendingInstallIncludeBackup,
                    syncMode,
                    pendingInstallButton,
                    pendingInstallOriginalText
                );
            } catch (e) {
                console.error('proceedWithSync error:', e);
                alert('Error: ' + e.message);
            }

            // Reset pending state
            pendingInstallSourceId = null;
            pendingInstallIncludeBackup = false;
            pendingInstallButton = null;
            pendingInstallOriginalText = '';
        }

        async function doInstall(sourceId, includeBackup, syncMode, btn, originalText) {
            btn.textContent = syncMode === 'replace' ? 'Replacing...' : 'Starting...';

            try {
                const response = await fetch('/useradmin/api/download-pack', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        source_id: sourceId,
                        include_backup: includeBackup,
                        sync_mode: syncMode
                    })
                });

                const data = await response.json();

                if (response.ok && data.status === 'submitted') {
                    // Job submitted successfully - show progress
                    btn.textContent = 'Downloading...';
                    pollJobStatus(data.job_id, btn, sourceId, originalText);
                } else if (response.status === 409) {
                    // Job already running
                    alert('A download is already in progress for this source.');
                    btn.textContent = originalText;
                    btn.disabled = false;
                    btn.style.opacity = '1';
                } else {
                    alert('Failed to start download: ' + (data.detail || 'Unknown error'));
                    btn.textContent = originalText;
                    btn.disabled = false;
                    btn.style.opacity = '1';
                }
            } catch (e) {
                alert('Error: ' + e.message);
                btn.textContent = originalText;
                btn.disabled = false;
                btn.style.opacity = '1';
            }
        }

        async function pollJobStatus(jobId, btn, sourceId, originalText) {
            try {
                const response = await fetch(`/useradmin/api/jobs/${jobId}`);
                const job = await response.json();

                if (job.status === 'running' || job.status === 'pending') {
                    // Still running - update button with progress
                    const progress = job.progress || 0;
                    btn.textContent = `${progress}%`;
                    setTimeout(() => pollJobStatus(jobId, btn, sourceId, originalText), 1000);
                } else if (job.status === 'completed') {
                    // Success! Update UI
                    btn.textContent = 'Installed';
                    btn.style.background = '#0f3460';
                    btn.style.color = '#4ecca3';

                    // Refresh sources list after a moment
                    setTimeout(() => {
                        loadSources();
                    }, 1500);
                } else {
                    // Failed
                    alert('Download failed: ' + (job.error || 'Unknown error'));
                    btn.textContent = originalText;
                    btn.disabled = false;
                    btn.style.opacity = '1';
                }
            } catch (e) {
                // Polling error - try again
                setTimeout(() => pollJobStatus(jobId, btn, sourceId, originalText), 2000);
            }
        }

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                currentFilter = tab.dataset.filter;
                renderSources();

                // Load models when switching to models tab
                if (tab.dataset.filter === 'models') {
                    loadModels();
                }

                // Load languages when switching to languages tab
                if (tab.dataset.filter === 'languages') {
                    loadLanguages();
                }
            });
        });

        // =============================================================================
        // MODEL MANAGEMENT
        // =============================================================================

        let modelsData = null;

        async function loadModels() {
            const embeddingContainer = document.getElementById('embeddingModels');
            const llmContainer = document.getElementById('llmModels');

            embeddingContainer.innerHTML = '<div class="loading">Loading models...</div>';
            llmContainer.innerHTML = '<div class="loading">Loading models...</div>';

            try {
                const response = await fetch('/useradmin/api/available-models');
                modelsData = await response.json();

                // Update system info
                if (modelsData.system_info) {
                    document.getElementById('systemRam').textContent = modelsData.system_info.ram_gb + ' GB';
                    document.getElementById('systemStorage').textContent = modelsData.system_info.disk_free_gb + ' GB free';
                    document.getElementById('systemTier').textContent = modelsData.system_info.tier.charAt(0).toUpperCase() + modelsData.system_info.tier.slice(1);
                }

                // Render embedding models
                const embeddingModels = modelsData.models.filter(m => m.type === 'embedding');
                if (embeddingModels.length === 0) {
                    embeddingContainer.innerHTML = '<div class="placeholder">No embedding models available</div>';
                } else {
                    embeddingContainer.innerHTML = embeddingModels.map(m => renderModelCard(m, modelsData.system_info)).join('');
                }

                // Render LLM models
                const llmModels = modelsData.models.filter(m => m.type === 'llm');
                if (llmModels.length === 0) {
                    llmContainer.innerHTML = '<div class="placeholder">No LLM models available</div>';
                } else {
                    llmContainer.innerHTML = llmModels.map(m => renderModelCard(m, modelsData.system_info)).join('');
                }

            } catch (e) {
                embeddingContainer.innerHTML = '<div class="placeholder">Error loading models: ' + e.message + '</div>';
                llmContainer.innerHTML = '';
            }
        }

        function renderModelCard(model, systemInfo) {
            const isInstalled = model.installed;
            const isActive = model.active;
            const isRecommended = (systemInfo && (
                (model.type === 'embedding' && model.id === systemInfo.recommended_embedding) ||
                (model.type === 'llm' && model.id === systemInfo.recommended_llm)
            ));

            let cardClasses = 'model-card';
            if (isActive) cardClasses += ' active';
            else if (isInstalled) cardClasses += ' installed';

            // Build badges
            let badges = '';
            if (isActive) badges += '<span class="model-badge active">Active</span>';
            if (isInstalled && !isActive) badges += '<span class="model-badge installed">Installed</span>';
            if (isRecommended) badges += '<span class="model-badge recommended">Recommended</span>';

            // Build meta info
            let meta = `<span>${model.size_mb} MB</span>`;
            meta += `<span>Min RAM: ${model.min_ram_gb} GB</span>`;
            if (model.dimensions) {
                meta += `<span>${model.dimensions}-dim</span>`;
            }
            if (model.tokens_per_sec) {
                meta += `<span>${model.tokens_per_sec} tok/s</span>`;
            }

            // Build action buttons
            let actions = '';
            if (isInstalled) {
                if (!isActive) {
                    actions = `<button class="btn-small btn-edit" onclick="setActiveModel('${model.id}')">Set Active</button>`;
                } else {
                    actions = `<span style="color: #4ecca3; font-size: 0.8rem;">Currently Active</span>`;
                }
            } else {
                actions = `<button class="btn-small btn-install" onclick="downloadModel('${model.id}', this)">Download</button>`;
            }

            return `
                <div class="${cardClasses}" id="model-card-${model.id}">
                    <h3>${escapeHtml(model.display_name)}</h3>
                    <div class="model-badges">${badges}</div>
                    <div class="model-meta">${meta}</div>
                    <div class="model-desc">${escapeHtml(model.description)}</div>
                    <div class="actions">${actions}</div>
                    <div class="progress-bar" id="progress-${model.id}" style="display: none;">
                        <div class="progress-fill" style="width: 0%;"></div>
                    </div>
                </div>
            `;
        }

        async function downloadModel(modelId, btn) {
            const originalText = btn.textContent;
            btn.disabled = true;
            btn.textContent = 'Starting...';
            btn.style.opacity = '0.7';

            try {
                const response = await fetch('/useradmin/api/download-model', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ model_id: modelId })
                });

                const data = await response.json();

                if (response.ok && data.status === 'submitted') {
                    // Show progress bar
                    const progressBar = document.getElementById('progress-' + modelId);
                    if (progressBar) progressBar.style.display = 'block';

                    btn.textContent = 'Downloading...';
                    pollModelDownload(data.job_id, modelId, btn, originalText);
                } else if (response.status === 409) {
                    alert('A download is already in progress for this model.');
                    btn.textContent = originalText;
                    btn.disabled = false;
                    btn.style.opacity = '1';
                } else {
                    alert('Failed to start download: ' + (data.detail || 'Unknown error'));
                    btn.textContent = originalText;
                    btn.disabled = false;
                    btn.style.opacity = '1';
                }
            } catch (e) {
                alert('Error: ' + e.message);
                btn.textContent = originalText;
                btn.disabled = false;
                btn.style.opacity = '1';
            }
        }

        async function pollModelDownload(jobId, modelId, btn, originalText) {
            try {
                const response = await fetch('/useradmin/api/jobs/' + jobId);
                const job = await response.json();

                // Update progress bar
                const progressBar = document.getElementById('progress-' + modelId);
                if (progressBar) {
                    const fill = progressBar.querySelector('.progress-fill');
                    if (fill) fill.style.width = (job.progress || 0) + '%';
                }

                if (job.status === 'running' || job.status === 'pending') {
                    btn.textContent = (job.progress || 0) + '%';
                    setTimeout(() => pollModelDownload(jobId, modelId, btn, originalText), 1000);
                } else if (job.status === 'completed') {
                    btn.textContent = 'Installed';
                    btn.style.background = '#0f3460';
                    btn.style.color = '#4ecca3';
                    if (progressBar) progressBar.style.display = 'none';

                    // Refresh models list
                    setTimeout(() => loadModels(), 1000);
                } else {
                    alert('Download failed: ' + (job.error || 'Unknown error'));
                    btn.textContent = originalText;
                    btn.disabled = false;
                    btn.style.opacity = '1';
                    if (progressBar) progressBar.style.display = 'none';
                }
            } catch (e) {
                setTimeout(() => pollModelDownload(jobId, modelId, btn, originalText), 2000);
            }
        }

        async function setActiveModel(modelId) {
            try {
                const response = await fetch('/useradmin/api/set-active-model', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ model_id: modelId })
                });

                const data = await response.json();

                if (response.ok) {
                    // Refresh models list
                    loadModels();
                } else {
                    alert('Failed to set active model: ' + (data.detail || 'Unknown error'));
                }
            } catch (e) {
                alert('Error: ' + e.message);
            }
        }

        // =============================================================================
        // LANGUAGE PACK MANAGEMENT
        // =============================================================================

        let languagesData = null;

        async function loadLanguages() {
            const container = document.getElementById('languagePacksList');
            container.innerHTML = '<div class="loading">Loading language packs...</div>';

            try {
                // Load available languages
                const langResponse = await fetch('/useradmin/api/available-languages');
                languagesData = await langResponse.json();

                // Load language status
                const statusResponse = await fetch('/useradmin/api/language-status');
                const statusData = await statusResponse.json();

                // Update status info
                if (statusData.active_language && statusData.active_language !== 'en') {
                    const langInfo = languagesData.languages.find(l => l.code === statusData.active_language);
                    document.getElementById('activeLanguage').textContent = langInfo ? langInfo.display_name : statusData.active_language;
                } else {
                    document.getElementById('activeLanguage').textContent = 'English (default)';
                }
                document.getElementById('translationEnabled').textContent = statusData.translation_enabled ? 'Yes' : 'No';
                document.getElementById('translationEnabled').style.color = statusData.translation_enabled ? '#4ecca3' : '#888';

                // Update cache stats
                if (statusData.cache) {
                    document.getElementById('cacheSize').textContent = (statusData.cache.size_mb || 0).toFixed(1) + ' MB';
                    document.getElementById('cachedArticleCount').textContent = statusData.cache.article_count || 0;
                    const cachedLangs = statusData.cache.languages || [];
                    document.getElementById('cachedLanguages').textContent = cachedLangs.length > 0 ? cachedLangs.join(', ') : 'None';
                }

                // Render language cards
                if (!languagesData.languages || languagesData.languages.length === 0) {
                    container.innerHTML = '<div class="placeholder">No language packs available</div>';
                } else {
                    container.innerHTML = languagesData.languages.map(lang => renderLanguageCard(lang, statusData)).join('');
                }

            } catch (e) {
                container.innerHTML = '<div class="placeholder">Error loading languages: ' + e.message + '</div>';
            }
        }

        function renderLanguageCard(lang, statusData) {
            const isInstalled = lang.installed;
            const isActive = statusData.active_language === lang.code;

            let cardClasses = 'model-card';
            if (isActive) cardClasses += ' active';
            else if (isInstalled) cardClasses += ' installed';

            // Build badges
            let badges = '';
            if (isActive) badges += '<span class="model-badge active">Active</span>';
            if (isInstalled && !isActive) badges += '<span class="model-badge installed">Installed</span>';
            if (lang.direction === 'rtl') badges += '<span class="model-badge" style="background: #4ecca320; color: #4ecca3;">RTL</span>';

            // Build meta info
            let meta = `<span>${lang.size_mb} MB</span>`;
            meta += `<span>Min RAM: ${lang.min_ram_gb} GB</span>`;
            meta += `<span>${lang.native_name}</span>`;

            // Build action buttons
            let actions = '';
            if (isInstalled) {
                if (!isActive) {
                    actions = `<button class="btn-small btn-edit" onclick="setActiveLanguage('${lang.code}')">Set Active</button>`;
                    actions += `<button class="btn-small btn-danger" onclick="removeLanguage('${lang.code}')" style="margin-left: 0.5rem;">Remove</button>`;
                } else {
                    actions = `<span style="color: #4ecca3; font-size: 0.8rem;">Currently Active</span>`;
                    actions += `<button class="btn-small btn-edit" onclick="disableTranslation()" style="margin-left: 0.5rem;">Disable</button>`;
                }
            } else {
                actions = `<button class="btn-small btn-install" onclick="downloadLanguage('${lang.code}', this)">Download</button>`;
            }

            return `
                <div class="${cardClasses}" id="lang-card-${lang.code}">
                    <h3>${escapeHtml(lang.display_name)}</h3>
                    <div class="model-badges">${badges}</div>
                    <div class="model-meta">${meta}</div>
                    <div class="model-desc">${escapeHtml(lang.description || 'MarianMT translation model for ' + lang.display_name)}</div>
                    <div class="actions">${actions}</div>
                    <div class="progress-bar" id="lang-progress-${lang.code}" style="display: none;">
                        <div class="progress-fill" style="width: 0%;"></div>
                    </div>
                </div>
            `;
        }

        async function downloadLanguage(langCode, btn) {
            const originalText = btn.textContent;
            btn.disabled = true;
            btn.textContent = 'Starting...';
            btn.style.opacity = '0.7';

            try {
                const response = await fetch('/useradmin/api/download-language', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ language_code: langCode })
                });

                const data = await response.json();

                if (response.ok && data.status === 'submitted') {
                    // Show progress bar
                    const progressBar = document.getElementById('lang-progress-' + langCode);
                    if (progressBar) progressBar.style.display = 'block';

                    btn.textContent = 'Downloading...';
                    pollLanguageDownload(data.job_id, langCode, btn, originalText);
                } else if (response.status === 409) {
                    alert('A download is already in progress for this language.');
                    btn.textContent = originalText;
                    btn.disabled = false;
                    btn.style.opacity = '1';
                } else {
                    alert('Failed to start download: ' + (data.detail || 'Unknown error'));
                    btn.textContent = originalText;
                    btn.disabled = false;
                    btn.style.opacity = '1';
                }
            } catch (e) {
                alert('Error: ' + e.message);
                btn.textContent = originalText;
                btn.disabled = false;
                btn.style.opacity = '1';
            }
        }

        async function pollLanguageDownload(jobId, langCode, btn, originalText) {
            try {
                const response = await fetch('/useradmin/api/jobs/' + jobId);
                const job = await response.json();

                // Update progress bar
                const progressBar = document.getElementById('lang-progress-' + langCode);
                if (progressBar) {
                    const fill = progressBar.querySelector('.progress-fill');
                    if (fill) fill.style.width = (job.progress || 0) + '%';
                }

                if (job.status === 'running' || job.status === 'pending') {
                    btn.textContent = (job.progress || 0) + '%';
                    setTimeout(() => pollLanguageDownload(jobId, langCode, btn, originalText), 1000);
                } else if (job.status === 'completed') {
                    btn.textContent = 'Installed';
                    btn.style.background = '#0f3460';
                    btn.style.color = '#4ecca3';
                    if (progressBar) progressBar.style.display = 'none';

                    // Refresh languages list
                    setTimeout(() => loadLanguages(), 1000);
                } else {
                    alert('Download failed: ' + (job.error || 'Unknown error'));
                    btn.textContent = originalText;
                    btn.disabled = false;
                    btn.style.opacity = '1';
                    if (progressBar) progressBar.style.display = 'none';
                }
            } catch (e) {
                setTimeout(() => pollLanguageDownload(jobId, langCode, btn, originalText), 2000);
            }
        }

        async function setActiveLanguage(langCode) {
            try {
                const response = await fetch('/useradmin/api/set-language', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ language_code: langCode })
                });

                const data = await response.json();

                if (response.ok) {
                    // Refresh languages list
                    loadLanguages();
                } else {
                    alert('Failed to set active language: ' + (data.detail || 'Unknown error'));
                }
            } catch (e) {
                alert('Error: ' + e.message);
            }
        }

        async function disableTranslation() {
            try {
                const response = await fetch('/useradmin/api/set-language', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ language_code: 'en' })
                });

                if (response.ok) {
                    loadLanguages();
                } else {
                    const data = await response.json();
                    alert('Failed to disable translation: ' + (data.detail || 'Unknown error'));
                }
            } catch (e) {
                alert('Error: ' + e.message);
            }
        }

        async function removeLanguage(langCode) {
            if (!confirm('Remove this language pack? Downloaded model files will be deleted.')) {
                return;
            }

            try {
                const response = await fetch('/useradmin/api/remove-language', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ language_code: langCode })
                });

                const data = await response.json();

                if (response.ok) {
                    loadLanguages();
                } else {
                    alert('Failed to remove language: ' + (data.detail || 'Unknown error'));
                }
            } catch (e) {
                alert('Error: ' + e.message);
            }
        }

        async function clearTranslationCache() {
            if (!confirm('Clear all cached article translations? This will not remove downloaded language packs.')) {
                return;
            }

            try {
                const response = await fetch('/useradmin/api/clear-translation-cache', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                const data = await response.json();

                if (response.ok) {
                    alert('Cleared ' + (data.cleared_count || 0) + ' cached translations.');
                    loadLanguages();
                } else {
                    alert('Failed to clear cache: ' + (data.detail || 'Unknown error'));
                }
            } catch (e) {
                alert('Error: ' + e.message);
            }
        }

        // Load languages for the "All" tab summary section
        async function loadLanguagesSummary() {
            const container = document.getElementById('languagesSection');
            if (!container) return;

            try {
                const response = await fetch('/useradmin/api/available-languages');
                const data = await response.json();

                const installed = (data.languages || []).filter(l => l.installed);
                if (installed.length === 0) {
                    container.innerHTML = '<div class="placeholder">No language packs installed. <a href="#" onclick="document.querySelector(\'[data-filter=languages]\').click(); return false;" style="color: #4ecca3;">Install one</a></div>';
                } else {
                    container.innerHTML = installed.map(lang => `
                        <div class="source-card source-card--complete">
                            <div class="source-card__header">
                                <h3 class="source-card__name">${escapeHtml(lang.display_name)}</h3>
                                <span class="source-card__badge source-card__badge--installed">Installed</span>
                            </div>
                            <div class="source-card__meta">
                                <span>${lang.native_name}</span>
                                <span>${lang.size_mb} MB</span>
                            </div>
                        </div>
                    `).join('');
                }
            } catch (e) {
                container.innerHTML = '<div class="placeholder">Error loading languages</div>';
            }
        }

        // Load models for the "All" tab summary section
        async function loadModelsSummary() {
            const container = document.getElementById('modelsSection');
            if (!container) return;

            try {
                const response = await fetch('/useradmin/api/available-models');
                const data = await response.json();

                const installed = (data.models || []).filter(m => m.installed);
                if (installed.length === 0) {
                    container.innerHTML = '<div class="placeholder">No models installed. <a href="#" onclick="document.querySelector(\'[data-filter=models]\').click(); return false;" style="color: #4ecca3;">Install one</a></div>';
                } else {
                    container.innerHTML = installed.map(model => `
                        <div class="source-card source-card--complete">
                            <div class="source-card__header">
                                <h3 class="source-card__name">${escapeHtml(model.display_name)}</h3>
                                <span class="source-card__badge ${model.active ? 'source-card__badge--ready' : 'source-card__badge--installed'}">${model.active ? 'Active' : 'Installed'}</span>
                            </div>
                            <div class="source-card__meta">
                                <span>${model.type === 'embedding' ? 'Embedding' : 'LLM'}</span>
                                <span>${model.size_mb} MB</span>
                            </div>
                        </div>
                    `).join('');
                }
            } catch (e) {
                container.innerHTML = '<div class="placeholder">Error loading models</div>';
            }
        }

        loadSources();
        loadLanguagesSummary();
        loadModelsSummary();

        // Handle URL hash to auto-select tab (e.g., #models)
        function selectTabFromHash() {
            const hash = window.location.hash.replace('#', '');
            if (hash) {
                const tab = document.querySelector(`.tab[data-filter="${hash}"]`);
                if (tab) {
                    tab.click();
                }
            }
        }
        selectTabFromHash();
        window.addEventListener('hashchange', selectTabFromHash);
    </script>
    <script src="/admin/static/source-card.js"></script>
    <script src="/admin/static/admin-common.js"></script>

    <script>
        // Attach source card event handlers
        function attachSourceCardHandlers() {
            // Sources page handlers
            SourceCard.attachHandlers(document.body, {
                onEdit: function(sourceId) {
                    window.location.href = '/useradmin/sources/tools?source=' + sourceId + '&step=2';
                },
                onInstall: function(sourceId, includeBackup, btn) {
                    installSource(sourceId, includeBackup);
                }
            });
        }

        // Attach handlers after DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', attachSourceCardHandlers);
        } else {
            attachSourceCardHandlers();
        }
    </script>

    <!-- Sync Mode Modal -->
    <div id="syncModeModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-title">Source Already Installed</div>
            <div class="modal-body">
                <p>The source <strong id="modalSourceId"></strong> already exists locally with <span class="count" id="modalVectorCount">0</span> vectors.</p>
                <p>How would you like to proceed?</p>
                <ul style="margin: 1rem 0; padding-left: 1.5rem; color: #aaa; font-size: 0.85rem;">
                    <li><strong>Update:</strong> Add new vectors, keep existing ones</li>
                    <li><strong>Replace:</strong> Delete old vectors first, then install fresh</li>
                </ul>
            </div>
            <div class="modal-actions">
                <button class="btn-small btn-update" id="btnSyncCancel">Cancel</button>
                <button class="btn-small btn-update" id="btnSyncUpdate">Update</button>
                <button class="btn-small btn-replace" id="btnSyncReplace">Replace</button>
            </div>
        </div>
    </div>

    <script>
        // Attach event listeners for modal buttons (CSP-compliant)
        document.getElementById('btnSyncCancel').addEventListener('click', closeSyncModal);
        document.getElementById('btnSyncUpdate').addEventListener('click', function() { proceedWithSync('update'); });
        document.getElementById('btnSyncReplace').addEventListener('click', function() { proceedWithSync('replace'); });
    </script>
</body>
</html>
