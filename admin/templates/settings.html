<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Local Admin - Disaster Clippy</title>
    <link rel="icon" type="image/png" href="/static/paperclip.png">
    <link rel="stylesheet" href="/admin/static/{{ admin_css }}">
    <style>
        /* Page-specific styles for settings.html */
        .status-bar {
            background: #0f3460;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 2rem;
            display: flex;
            gap: 2rem;
            flex-wrap: wrap;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .status-dot.online { background: #4ecca3; }
        .status-dot.offline { background: #e94560; }
        .status-dot.hybrid { background: #f9a825; }

        .section p.description {
            color: #888;
            font-size: 0.85rem;
            margin-bottom: 1rem;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #ccc;
            font-size: 0.9rem;
        }

        .form-group input[type="text"],
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #0f3460;
            border-radius: 6px;
            background: #1a1a2e;
            color: #eee;
            font-size: 0.95rem;
        }

        .form-group textarea {
            min-height: 150px;
            font-family: monospace;
            resize: vertical;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #4ecca3;
        }

        .prompt-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.75rem;
        }

        .btn-small {
            padding: 0.5rem 1rem;
            font-size: 0.85rem;
        }

        .path-input-group {
            display: flex;
            gap: 0.5rem;
        }

        .path-input-group input {
            flex: 1;
        }

        .path-input-group button {
            padding: 0.75rem 1rem;
            background: #0f3460;
            border: 1px solid #4ecca3;
            color: #4ecca3;
            border-radius: 6px;
            cursor: pointer;
            white-space: nowrap;
        }

        .path-input-group button:hover {
            background: #4ecca3;
            color: #1a1a2e;
        }

        .radio-group {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .radio-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1rem;
            background: #1a1a2e;
            border: 1px solid #0f3460;
            border-radius: 6px;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        .radio-option:hover {
            border-color: #4ecca3;
        }

        .radio-option.selected {
            border-color: #4ecca3;
            background: #0f3460;
        }

        .radio-option input {
            accent-color: #4ecca3;
        }

        .checkbox-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }

        .checkbox-option input {
            accent-color: #4ecca3;
            width: 18px;
            height: 18px;
        }

        .backup-summary {
            margin-top: 1rem;
            padding: 1rem;
            background: #1a1a2e;
            border-radius: 6px;
        }

        .backup-summary h4 {
            font-size: 0.9rem;
            color: #4ecca3;
            margin-bottom: 0.75rem;
        }

        .backup-counts {
            display: flex;
            gap: 2rem;
            flex-wrap: wrap;
        }

        .backup-count {
            text-align: center;
        }

        .backup-count .number {
            font-size: 1.5rem;
            font-weight: bold;
            color: #e94560;
        }

        .backup-count .label {
            font-size: 0.8rem;
            color: #888;
        }

        .file-list {
            background: #1a1a2e;
            border-radius: 6px;
            padding: 0.5rem;
            max-height: 150px;
            overflow-y: auto;
            margin-top: 0.5rem;
        }

        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            border-bottom: 1px solid #0f3460;
        }

        .file-item:last-child {
            border-bottom: none;
        }

        .file-name {
            color: #4ecca3;
        }

        .file-size {
            color: #888;
            font-size: 0.85rem;
        }

        .empty-list {
            color: #666;
            text-align: center;
            padding: 1rem;
        }

        .btn-small {
            padding: 0.5rem 1rem;
            font-size: 0.85rem;
        }

        .btn-primary {
            background: #e94560;
            color: white;
        }

        .btn-primary:hover {
            background: #ff6b6b;
        }

        .btn-secondary {
            background: #0f3460;
            color: #4ecca3;
            border: 1px solid #4ecca3;
        }

        .btn-secondary:hover {
            background: #4ecca3;
            color: #1a1a2e;
        }

        .actions {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
        }

        .toast {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: #4ecca3;
            color: #1a1a2e;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            font-weight: 500;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
        }

        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }

        .toast.error {
            background: #e94560;
            color: white;
        }

        .mode-description {
            font-size: 0.8rem;
            color: #666;
            margin-top: 0.25rem;
        }

        .collapsible {
            margin-top: 0.5rem;
        }

        .collapsible-header {
            cursor: pointer;
            color: #888;
            font-size: 0.85rem;
        }

        .collapsible-header:hover {
            color: #4ecca3;
        }

        .collapsible-content {
            display: none;
        }

        .collapsible-content.open {
            display: block;
        }

        @media (max-width: 600px) {
            .container {
                padding: 1rem;
            }
            .radio-group {
                flex-direction: column;
            }
            .status-bar {
                flex-direction: column;
                gap: 0.75rem;
            }
        }
    </style>
</head>
<body>
    <header>
        <div>
            <h1>Local Admin Panel</h1>
            <p>Manage your offline disaster preparedness system</p>
        </div>
        {% with active_page='settings' %}{% include '_nav.html' %}{% endwith %}
    </header>

    <div class="container">
        <!-- Status Bar -->
        <div class="status-bar">
            <div class="status-item">
                <span class="status-dot" id="connectionDot"></span>
                <span id="connectionStateText">Checking...</span>
            </div>
            <div class="status-item">
                <span class="status-dot hybrid" id="modeDot"></span>
                <span id="modeStatus">Mode: Loading...</span>
            </div>
            <div class="status-item">
                <span id="backupStatus">Backups: Loading...</span>
            </div>
        </div>

        <!-- Offline Mode Section -->
        <div class="section">
            <h2>Connection Mode</h2>
            <p class="description">Choose how your system handles internet connectivity</p>

            <div class="radio-group" id="offlineModeGroup">
                <label class="radio-option" data-mode="online_only">
                    <input type="radio" name="offline_mode" value="online_only">
                    <div>
                        <span>Online Only</span>
                        <div class="mode-description">Always use live internet sources</div>
                    </div>
                </label>
                <label class="radio-option" data-mode="hybrid">
                    <input type="radio" name="offline_mode" value="hybrid">
                    <div>
                        <span>Hybrid (Recommended)</span>
                        <div class="mode-description">Use internet when available, fallback to offline</div>
                    </div>
                </label>
                <label class="radio-option" data-mode="offline_only">
                    <input type="radio" name="offline_mode" value="offline_only">
                    <div>
                        <span>Offline Only</span>
                        <div class="mode-description">Only use local backup files</div>
                    </div>
                </label>
            </div>

            <div class="form-group" style="margin-top: 1rem;">
                <label class="checkbox-option">
                    <input type="checkbox" id="autoFallback" checked>
                    <span>Auto-fallback to offline when internet unavailable</span>
                </label>
            </div>
        </div>

        <!-- Embedding Model Section -->
        <div class="section">
            <h2>Embedding Model</h2>
            <p class="description">Choose the embedding model for offline semantic search. Different models require different hardware resources. 768 dimensions is the default for offline and is available for download, other dimensions will be custom and unique to your system.</p>

            <div class="form-group">
                <label>Active Embedding Model</label>
                <select id="embeddingModel">
                    <option value="all-MiniLM-L6-v2">MiniLM L6 (384-dim) - Fast, 80MB, 2GB RAM</option>
                    <option value="all-mpnet-base-v2" selected>MPNet Base v2 (768-dim) - Recommended, 420MB, 4GB RAM</option>
                    <option value="intfloat-e5-large-v2">E5 Large v2 (1024-dim) - High Quality, 1.3GB, 8GB RAM</option>
                </select>
            </div>

            <div style="background: #1a1a2e; border-radius: 6px; padding: 1rem; margin-top: 1rem;">
                <strong style="color: #4ecca3;">Hardware Guidelines:</strong>
                <ul style="color: #888; font-size: 0.85rem; margin-top: 0.75rem; margin-left: 1.5rem; line-height: 1.8;">
                    <li><strong style="color: #ccc;">MiniLM (384-dim)</strong> - Raspberry Pi 4, older laptops, phones. Fastest inference but lower accuracy.</li>
                    <li><strong style="color: #ccc;">MPNet (768-dim)</strong> - Standard laptops/desktops with 4GB+ RAM. Best balance of speed and quality.</li>
                    <li><strong style="color: #ccc;">E5 Large (1024-dim)</strong> - Desktops with 8GB+ RAM. Best semantic matching, slower inference.</li>
                </ul>
            </div>

            <div style="background: #0f3460; border: 1px solid #f9a825; border-radius: 6px; padding: 1rem; margin-top: 1rem;">
                <strong style="color: #f9a825;">Important:</strong>
                <p style="color: #888; font-size: 0.85rem; margin-top: 0.5rem;">
                    Changing the embedding model requires re-indexing your sources. Each dimension uses a separate ChromaDB database
                    (e.g., <code>chroma_db_768</code>). Download the model from the <a href="/useradmin/models" style="color: #4ecca3;">Models</a> page before indexing.
                </p>
            </div>

            <div class="prompt-actions">
                <button class="btn btn-primary btn-small" onclick="saveEmbeddingModel()">Save Embedding Model</button>
            </div>
        </div>

        <!-- System Prompt (unified for all LLMs) -->
        <div class="section">
            <h2>System Prompt</h2>
            <p class="description" id="promptDescription">
                Customize the AI assistant's behavior. This prompt is used for all LLMs (cloud and local). The prompt format is automatically adjusted based on the model being used.
            </p>

            <div class="form-group">
                <textarea id="promptEditor" rows="10" placeholder="Enter system prompt..."></textarea>
            </div>

            <div class="prompt-actions">
                <button class="btn btn-secondary btn-small" onclick="resetCurrentPrompt()">Reset to Default</button>
                <button class="btn btn-primary btn-small" onclick="savePrompts()">Save Prompt</button>
            </div>
        </div>

        <!-- Unified Backup Folder Section -->
        <div class="section">
            <h2>Backup Location</h2>
            <p class="description">Set the folder containing your offline backups (ZIM files, HTML folders, PDFs)</p>

            <div class="form-group">
                <label>Backup Folder</label>
                <div class="path-input-group">
                    <input type="text" id="backupFolder" placeholder="e.g. D:\backups or /home/user/backups">
                    <button onclick="validateAndScanBackups()">Save</button>
                </div>
            </div>

            <div class="backup-summary" id="backupSummary" style="display: none;">
                <h4>Found Backups:</h4>
                <div class="backup-counts">
                    <div class="backup-count">
                        <div class="number" id="zimCount">0</div>
                        <div class="label">ZIM Files</div>
                    </div>
                    <div class="backup-count">
                        <div class="number" id="htmlCount">0</div>
                        <div class="label">HTML Sites</div>
                    </div>
                    <div class="backup-count">
                        <div class="number" id="pdfCount">0</div>
                        <div class="label">PDF Files</div>
                    </div>
                </div>

                <!-- Collapsible file lists -->
                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleList('zim')">[+] Show ZIM files</div>
                    <div class="collapsible-content" id="zimList">
                        <div class="file-list" id="zimFileList"></div>
                    </div>
                </div>

                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleList('html')">[+] Show HTML folders</div>
                    <div class="collapsible-content" id="htmlList">
                        <div class="file-list" id="htmlFileList"></div>
                    </div>
                </div>

                <div class="collapsible">
                    <div class="collapsible-header" onclick="toggleList('pdf')">[+] Show PDF files</div>
                    <div class="collapsible-content" id="pdfList">
                        <div class="file-list" id="pdfFileList"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Personal Cloud Backup -->
        <div class="section">
            <h2>Personal Cloud Backup</h2>
            <p class="description">
                Connect your own S3-compatible cloud storage for personal backups and sync.
                Supports Cloudflare R2, AWS S3, Backblaze B2, and other S3-compatible services.
            </p>

            <div class="form-group">
                <label class="checkbox-option">
                    <input type="checkbox" id="cloudEnabled">
                    <span>Enable Personal Cloud Backup</span>
                </label>
            </div>

            <div id="cloudSettings" style="display: none;">
                <div class="form-group">
                    <label>Cloud Storage Provider</label>
                    <select id="cloudProvider">
                        <option value="r2">Cloudflare R2</option>
                        <option value="s3">Amazon S3</option>
                        <option value="backblaze">Backblaze B2</option>
                        <option value="digitalocean">DigitalOcean Spaces</option>
                        <option value="custom">Custom S3-Compatible</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>Endpoint URL</label>
                    <input type="text" id="cloudEndpoint" placeholder="https://...">
                    <p class="description">Auto-filled based on provider. For R2, use: https://YOUR-ACCOUNT-ID.r2.cloudflarestorage.com</p>
                </div>

                <p style="font-size: 0.85rem; color: #888; margin-top: 1rem; font-style: italic;">
                    Prefer manual configuration? See <code>DEVELOPER.md - Personal Cloud Backup</code> for JSON-based setup and CLI integration.
                </p>

                <div class="form-group">
                    <label>Access Key ID</label>
                    <input type="password" id="cloudAccessKey" placeholder="Enter access key">
                </div>

                <div class="form-group">
                    <label>Secret Access Key</label>
                    <input type="password" id="cloudSecretKey" placeholder="Enter secret key">
                </div>

                <div class="form-group">
                    <label>Bucket Name</label>
                    <input type="text" id="cloudBucket" placeholder="my-backup-bucket">
                </div>

                <div class="form-group">
                    <label>Region (Optional)</label>
                    <input type="text" id="cloudRegion" value="auto" placeholder="auto">
                    <p class="description">Use "auto" for R2, or specify region like "us-east-1" for S3</p>
                </div>

                <div class="prompt-actions">
                    <button class="btn btn-secondary btn-small" onclick="testCloudConnection()">Test Connection</button>
                    <button class="btn btn-primary btn-small" onclick="saveCloudSettings()">Save Cloud Settings</button>
                </div>

                <div id="cloudTestResult" style="display: none; margin-top: 1rem; padding: 1rem; border-radius: 6px;">
                </div>

                <div style="background: #1a1a2e; border: 1px solid #0f3460; border-radius: 6px; padding: 1rem; margin-top: 1rem;">
                    <strong style="color: #e94560;">Security Note:</strong>
                    <p style="color: #888; font-size: 0.85rem; margin-top: 0.5rem;">
                        Your cloud credentials are stored in <code>local_settings.json</code>. Keep this file secure:
                    </p>
                    <ul style="color: #888; font-size: 0.85rem; margin-top: 0.5rem; margin-left: 1.5rem;">
                        <li>Never commit it to git (already protected by .gitignore)</li>
                        <li>Never share it publicly</li>
                        <li>On Linux/Mac: Run <code>chmod 600 local_settings.json</code></li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Advanced Options -->
        <div class="section">
            <h2>Advanced Options</h2>
            <div class="form-group">
                <label class="checkbox-option">
                    <input type="checkbox" id="cacheResponses" checked>
                    <span>Cache AI responses for offline use</span>
                </label>
                <p class="description" style="margin-left: 26px; margin-top: 0.5rem;">
                    Save LLM responses locally so they can be reused when offline (coming soon)
                </p>
            </div>
        </div>

        <!-- Actions -->
        <div class="actions">
            <button class="btn btn-primary" onclick="saveSettings()">Save All Settings</button>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <script src="/admin/static/admin-common.js"></script>
    <script>
        let currentSettings = {};
        let currentPrompt = '';
        let defaultPrompt = '';

        // Load settings on page load
        async function loadSettings() {
            try {
                const response = await fetch('/useradmin/api/settings');
                const data = await response.json();
                currentSettings = data.settings;

                // Update internet status
                updateInternetStatus(data.internet_available);

                // Update offline mode
                const mode = currentSettings.offline_mode || 'hybrid';
                document.querySelector(`input[value="${mode}"]`).checked = true;
                updateModeSelection(mode);

                // Update auto fallback
                document.getElementById('autoFallback').checked = currentSettings.auto_fallback !== false;

                // Update cache responses
                document.getElementById('cacheResponses').checked = currentSettings.cache_responses !== false;

                // Update backup folder (use unified path or legacy)
                const backupFolder = currentSettings.backup_folder ||
                                    currentSettings.backup_paths?.zim_folder || '';
                document.getElementById('backupFolder').value = backupFolder;

                // Scan backups if path is set
                if (backupFolder) {
                    scanAllBackups();
                }

                // Load unified prompt from settings
                if (currentSettings.prompts) {
                    // Support both new "system" key and legacy "online" key
                    currentPrompt = currentSettings.prompts.system || currentSettings.prompts.online || '';
                }

                // Load cloud settings
                if (currentSettings.personal_cloud) {
                    loadCloudSettings(currentSettings.personal_cloud);
                }

                // Load embedding model
                if (currentSettings.models && currentSettings.models.embedding_model) {
                    document.getElementById('embeddingModel').value = currentSettings.models.embedding_model;
                }

                // Also fetch default prompts
                await loadDefaultPrompts();

                // If no prompt in settings, use default
                if (!currentPrompt) {
                    currentPrompt = defaultPrompt;
                }

                // Update the editor
                document.getElementById('promptEditor').value = currentPrompt;

            } catch (e) {
                console.error('Failed to load settings:', e);
                showToast('Failed to load settings', true);
            }
        }

        async function loadDefaultPrompts() {
            try {
                const response = await fetch('/useradmin/api/prompts');
                const data = await response.json();
                if (data.defaults) {
                    // Support both new "system" key and legacy "online" key
                    defaultPrompt = data.defaults.system || data.defaults.online || '';
                }
                // Also update current prompt if we got one
                if (data.prompts) {
                    currentPrompt = data.prompts.system || data.prompts.online || '';
                }
            } catch (e) {
                console.error('Failed to load default prompts:', e);
            }
        }

        async function savePrompts() {
            // Update current prompt from editor
            currentPrompt = document.getElementById('promptEditor').value;

            try {
                const response = await fetch('/useradmin/api/settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompts: { system: currentPrompt } })
                });

                const data = await response.json();
                if (data.status === 'success') {
                    showToast('Prompt saved successfully');
                } else {
                    showToast('Failed to save prompt', true);
                }
            } catch (e) {
                showToast('Error saving prompt', true);
            }
        }

        async function saveEmbeddingModel() {
            const embeddingModel = document.getElementById('embeddingModel').value;

            try {
                const response = await fetch('/useradmin/api/settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        models: {
                            embedding_model: embeddingModel
                        }
                    })
                });

                const data = await response.json();
                if (data.status === 'success') {
                    showToast('Embedding model saved. Re-index your sources to use the new model.');
                } else {
                    showToast('Failed to save embedding model', true);
                }
            } catch (e) {
                showToast('Error saving embedding model', true);
            }
        }

        async function resetCurrentPrompt() {
            if (!confirm('Reset the prompt to default? Your changes will be lost.')) {
                return;
            }

            if (defaultPrompt) {
                currentPrompt = defaultPrompt;
                document.getElementById('promptEditor').value = defaultPrompt;

                // Save to backend
                try {
                    const response = await fetch('/useradmin/api/settings', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ prompts: { system: currentPrompt } })
                    });

                    const data = await response.json();
                    if (data.status === 'success') {
                        showToast('Prompt reset to default');
                    } else {
                        showToast('Prompt reset locally, but failed to save to server', true);
                    }
                } catch (e) {
                    showToast('Prompt reset locally, but failed to save to server', true);
                }
            } else {
                showToast('Default prompt not available', true);
            }
        }

        // Connection state colors mapping
        const connectionStateColors = {
            'green': 'online',
            'blue': 'hybrid',   // reuse hybrid style for blue
            'yellow': 'hybrid',
            'orange': 'hybrid',
            'red': 'offline',
            'gray': 'offline'
        };

        async function loadConnectionState() {
            try {
                const response = await fetch('/api/v1/connection-status');
                const data = await response.json();

                const dot = document.getElementById('connectionDot');
                const text = document.getElementById('connectionStateText');

                // Map state_color to CSS class
                const dotClass = connectionStateColors[data.state_color] || 'hybrid';
                dot.className = 'status-dot ' + dotClass;
                text.textContent = data.state_label + ': ' + (data.message || '');
            } catch (e) {
                console.error('Error loading connection state:', e);
                document.getElementById('connectionStateText').textContent = 'Status: Error';
            }
        }

        function updateInternetStatus(available) {
            // This is now handled by loadConnectionState() using the unified endpoint
            // Keep for backward compatibility but it will be overwritten by loadConnectionState
            const dot = document.getElementById('connectionDot');
            const status = document.getElementById('connectionStateText');

            if (available) {
                dot.className = 'status-dot online';
                status.textContent = 'Connected';
            } else {
                dot.className = 'status-dot offline';
                status.textContent = 'Disconnected';
            }
        }

        function updateModeSelection(mode) {
            document.querySelectorAll('.radio-option').forEach(opt => {
                opt.classList.remove('selected');
                if (opt.dataset.mode === mode) {
                    opt.classList.add('selected');
                }
            });

            const modeDot = document.getElementById('modeDot');
            const modeStatus = document.getElementById('modeStatus');

            const modeLabels = {
                'online_only': 'Online Only',
                'hybrid': 'Hybrid',
                'offline_only': 'Offline Only'
            };

            modeDot.className = 'status-dot ' + mode.replace('_only', '');
            modeStatus.textContent = 'Mode: ' + modeLabels[mode];
        }

        // Handle radio button changes - auto-save when mode changes
        document.querySelectorAll('input[name="offline_mode"]').forEach(radio => {
            radio.addEventListener('change', async (e) => {
                const newMode = e.target.value;
                updateModeSelection(newMode);

                // Auto-save the mode change
                try {
                    const response = await fetch('/useradmin/api/settings', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ offline_mode: newMode })
                    });

                    const data = await response.json();
                    if (data.status === 'success') {
                        showToast('Connection mode saved');
                    } else {
                        showToast('Failed to save connection mode', true);
                    }
                } catch (err) {
                    showToast('Error saving connection mode', true);
                }
            });
        });

        async function validateAndScanBackups() {
            const path = document.getElementById('backupFolder').value;

            if (!path) {
                showToast('Please enter a path first', true);
                return;
            }

            try {
                const response = await fetch('/useradmin/api/validate-path', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: path })
                });

                const data = await response.json();

                if (data.valid) {
                    // Save the path
                    await fetch('/useradmin/api/backup-path', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ path_type: 'backup_folder', path: path })
                    });
                    showToast('Path verified');
                    scanAllBackups();
                } else {
                    showToast(data.error || 'Invalid path', true);
                }
            } catch (e) {
                showToast('Error validating path', true);
            }
        }

        async function scanAllBackups() {
            try {
                const response = await fetch('/useradmin/api/scan-backups');
                const data = await response.json();

                const zimFiles = data.zim_files || [];
                const htmlFiles = data.html_files || [];
                const pdfFiles = data.pdf_files || [];

                // Update counts
                document.getElementById('zimCount').textContent = zimFiles.length;
                document.getElementById('htmlCount').textContent = htmlFiles.length;
                document.getElementById('pdfCount').textContent = pdfFiles.length;

                // Render file lists
                renderFileList('zimFileList', zimFiles);
                renderFileList('htmlFileList', htmlFiles);
                renderFileList('pdfFileList', pdfFiles);

                // Show summary
                document.getElementById('backupSummary').style.display = 'block';

                // Update status bar
                const totalFiles = zimFiles.length + htmlFiles.length + pdfFiles.length;
                document.getElementById('backupStatus').textContent =
                    `Backups: ${totalFiles} items`;

            } catch (e) {
                console.error('Failed to scan backups:', e);
            }
        }

        function renderFileList(elementId, files) {
            const container = document.getElementById(elementId);

            if (!files || files.length === 0) {
                container.innerHTML = '<div class="empty-list">No files found</div>';
                return;
            }

            container.innerHTML = files.map(file => `
                <div class="file-item">
                    <span class="file-name">${escapeHtml(file.name)}</span>
                    <span class="file-size">${file.size_mb} MB</span>
                </div>
            `).join('');
        }

        function toggleList(type) {
            const content = document.getElementById(type + 'List');
            const header = content.previousElementSibling;

            if (content.classList.contains('open')) {
                content.classList.remove('open');
                header.textContent = header.textContent.replace('[-]', '[+]');
            } else {
                content.classList.add('open');
                header.textContent = header.textContent.replace('[+]', '[-]');
            }
        }

        async function saveSettings() {
            const settings = {
                offline_mode: document.querySelector('input[name="offline_mode"]:checked').value,
                auto_fallback: document.getElementById('autoFallback').checked,
                cache_responses: document.getElementById('cacheResponses').checked,
                backup_folder: document.getElementById('backupFolder').value
            };

            try {
                const response = await fetch('/useradmin/api/settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(settings)
                });

                const data = await response.json();

                if (data.status === 'success') {
                    showToast('Settings saved successfully');
                    currentSettings = data.settings;
                } else {
                    showToast('Failed to save settings', true);
                }
            } catch (e) {
                showToast('Error saving settings', true);
            }
        }

        function showToast(message, isError = false) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast' + (isError ? ' error' : '');
            toast.classList.add('show');

            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Personal Cloud Backup functions
        const providerEndpoints = {
            'r2': 'https://YOUR-ACCOUNT-ID.r2.cloudflarestorage.com',
            's3': 'https://s3.amazonaws.com',
            'backblaze': 'https://s3.us-west-002.backblazeb2.com',
            'digitalocean': 'https://nyc3.digitaloceanspaces.com'
        };

        document.getElementById('cloudEnabled').addEventListener('change', function(e) {
            const settings = document.getElementById('cloudSettings');
            settings.style.display = e.target.checked ? 'block' : 'none';
        });

        document.getElementById('cloudProvider').addEventListener('change', function(e) {
            const endpoint = providerEndpoints[e.target.value];
            if (endpoint) {
                document.getElementById('cloudEndpoint').value = endpoint;
            }
        });

        async function testCloudConnection() {
            const resultDiv = document.getElementById('cloudTestResult');
            resultDiv.style.display = 'block';
            resultDiv.innerHTML = '<p>Testing connection...</p>';
            resultDiv.style.background = '#1a1a2e';
            resultDiv.style.border = '1px solid #0f3460';

            const config = {
                provider: document.getElementById('cloudProvider').value,
                endpoint_url: document.getElementById('cloudEndpoint').value,
                access_key_id: document.getElementById('cloudAccessKey').value,
                secret_access_key: document.getElementById('cloudSecretKey').value,
                bucket_name: document.getElementById('cloudBucket').value,
                region: document.getElementById('cloudRegion').value
            };

            try {
                const response = await fetch('/useradmin/api/test-cloud-connection', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });

                const data = await response.json();

                if (data.connected && data.bucket_exists) {
                    resultDiv.innerHTML = '<p style="color: #4ecca3;">Connection successful! Bucket found.</p>';
                    resultDiv.style.background = '#0f3460';
                    resultDiv.style.border = '1px solid #4ecca3';
                } else if (data.connected) {
                    resultDiv.innerHTML = '<p style="color: #f9a825;">Connected, but bucket not found. Check bucket name.</p>';
                    resultDiv.style.background = '#1a1a2e';
                    resultDiv.style.border = '1px solid #f9a825';
                } else {
                    resultDiv.innerHTML = `<p style="color: #e94560;">Connection failed: ${data.error || 'Unknown error'}</p>`;
                    resultDiv.style.background = '#1a1a2e';
                    resultDiv.style.border = '1px solid #e94560';
                }
            } catch (e) {
                resultDiv.innerHTML = `<p style="color: #e94560;">Test failed: ${e.message}</p>`;
                resultDiv.style.background = '#1a1a2e';
                resultDiv.style.border = '1px solid #e94560';
            }
        }

        async function saveCloudSettings() {
            const config = {
                enabled: document.getElementById('cloudEnabled').checked,
                provider: document.getElementById('cloudProvider').value,
                endpoint_url: document.getElementById('cloudEndpoint').value,
                access_key_id: document.getElementById('cloudAccessKey').value,
                secret_access_key: document.getElementById('cloudSecretKey').value,
                bucket_name: document.getElementById('cloudBucket').value,
                region: document.getElementById('cloudRegion').value
            };

            try {
                const response = await fetch('/useradmin/api/settings', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ personal_cloud: config })
                });

                const data = await response.json();
                if (data.status === 'success') {
                    showToast('Cloud settings saved successfully');
                } else {
                    showToast('Failed to save cloud settings', true);
                }
            } catch (e) {
                showToast('Error saving cloud settings', true);
            }
        }

        function loadCloudSettings(cloud) {
            if (!cloud) return;

            document.getElementById('cloudEnabled').checked = cloud.enabled || false;
            document.getElementById('cloudSettings').style.display = cloud.enabled ? 'block' : 'none';
            document.getElementById('cloudProvider').value = cloud.provider || 'r2';
            document.getElementById('cloudEndpoint').value = cloud.endpoint_url || '';
            document.getElementById('cloudBucket').value = cloud.bucket_name || '';
            document.getElementById('cloudRegion').value = cloud.region || 'auto';

            // Access keys are masked - only show if they exist
            if (cloud.access_key_id) {
                document.getElementById('cloudAccessKey').value = cloud.access_key_id;
                document.getElementById('cloudAccessKey').placeholder = 'Already configured (masked)';
            }
            if (cloud.secret_access_key) {
                document.getElementById('cloudSecretKey').value = cloud.secret_access_key;
                document.getElementById('cloudSecretKey').placeholder = 'Already configured (masked)';
            }
        }

        // Initialize
        loadSettings();
        loadConnectionState();  // Load live connection state from unified endpoint
    </script>
</body>
</html>
